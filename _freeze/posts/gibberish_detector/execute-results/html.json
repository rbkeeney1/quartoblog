{
  "hash": "609b90b7985684e7cd8d577531da47c0",
  "result": {
    "markdown": "---\ntitle: \"Gibberish Detector\"\nauthor: \"Ryan Keeney\"\neditor: visual\nexecute:\n  freeze: true\n---\n\n\n# Introduction\n\nSurveys may contain responses that are gibberish - unintelligible or meaningless language. It would be useful to identify these entries automatically.\n\n# Basic Gibberish Detector\n\nOur basic gibberish detector will calculate the ratio of real words in string.\n\n## Setup\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) # basic R useability \nlibrary(hunspell) # spell checker (and other stuff)\nlibrary(textcat) # language prediction\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  id = c('english', 'ipsum', 'gibberish', 'spanish', 'quadratic'),\n  text = c(\n    'Contrary to popular belief, that is not simply random text.',\n    'Et harum quidem rerum facilis est et expedita distinctio',\n    'All mimsy were the borogoves, And the mome raths outgrabe',\n    'es un hermoso dia para ir a caminar en el parque',\n    'Negative b plus or minus the square root of B squared minus four ac over two a'\n  )\n)\n\n# display\ndf |> knitr::kable()\n```\n\n::: {.cell-output-display}\n|id        |text                                                                           |\n|:---------|:------------------------------------------------------------------------------|\n|english   |Contrary to popular belief, that is not simply random text.                    |\n|ipsum     |Et harum quidem rerum facilis est et expedita distinctio                       |\n|gibberish |All mimsy were the borogoves, And the mome raths outgrabe                      |\n|spanish   |es un hermoso dia para ir a caminar en el parque                               |\n|quadratic |Negative b plus or minus the square root of B squared minus four ac over two a |\n:::\n:::\n\n\nLet's create a simple function that returns the ratio of correct words in a given string.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nword_ratio <- function(input_text, show_output=FALSE){\n  \n  if (show_output==TRUE){ glue::glue('input text: {input_text}') |> print()}\n\n  # replace '-' with space and remove all punctuation \n  temp <- input_text |> \n    str_replace(\"-\", \" \") |> \n    str_replace_all(\"[[:punct:]]\", \"\")\n  \n  if (show_output==TRUE){glue::glue('predicted language: {textcat(temp)}') |> print()}\n  \n  # split string\n  temp <- str_split(temp,' ',simplify = TRUE)\n  \n  # spell check\n  temp <- hunspell_check(temp)\n  \n  # calc ratio\n  ratio_correct = length(temp[temp])/length(temp)\n  \n  if (show_output==TRUE){  glue::glue('correct/total words: {length(temp[temp])}/{length(temp)}') |> print()}\n\n  return(ratio_correct)\n}\n```\n:::\n\n\nLet's test it out.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nratio = word_ratio(input_text = df$text[1], show_output = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninput text: Contrary to popular belief, that is not simply random text.\npredicted language: english\ncorrect/total words: 10/10\n```\n:::\n\n```{.r .cell-code}\nprint(ratio)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nLet's apply our function to our example tibble.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  rowwise() |> \n  mutate(\n    ratio = word_ratio(text),\n    language = textcat(text),\n    gibberish = ifelse(ratio>0.75,FALSE,TRUE)\n    ) |> \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n|id        |text                                                                           |     ratio|language |gibberish |\n|:---------|:------------------------------------------------------------------------------|---------:|:--------|:---------|\n|english   |Contrary to popular belief, that is not simply random text.                    | 1.0000000|english  |FALSE     |\n|ipsum     |Et harum quidem rerum facilis est et expedita distinctio                       | 0.1111111|latin    |TRUE      |\n|gibberish |All mimsy were the borogoves, And the mome raths outgrabe                      | 0.5000000|english  |TRUE      |\n|spanish   |es un hermoso dia para ir a caminar en el parque                               | 0.3636364|spanish  |TRUE      |\n|quadratic |Negative b plus or minus the square root of B squared minus four ac over two a | 1.0000000|english  |FALSE     |\n:::\n:::\n\n\n## Basic method advantages\n\n1.  Lightweight solution with minimal computational effort\n2.  Adaptable to different languages\n\n## Basic method shortcomings\n\n1.  Dependent on spelling. If a customer inputs 'computr' instead of 'computer', then the basic algorithm will treat it as gibberish. There are methods for compensating for this, such as calculating suggested words through string-to-string edit distance.\n2.  Will not detect gibberish that are real words, but nonsensical. For example 'car shiny computer running tree' doesn't make any sense but will pass our test.\n\n# Advanced Gibberish Detectors\n\n**In progress**\n\nTo address the above shortcomings, we could use a more advanced approach. Such as a 2 character markov chain to predict how often characters (or words) occur next to one another.\n\n# References\n\n1.  https://github.com/domanchi/gibberish-detector\n2.  https://github.com/rrenaud/Gibberish-Detector\n3.  https://github.com/glender/gibber\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}